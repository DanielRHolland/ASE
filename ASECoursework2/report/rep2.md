


QuickCheck

In order to test the function `removeHeavierDuplicates` with a wider range of test data, the QuickCheck testing library was used. 

As the function takes a list of Edges as a parameter, `Edge` needed an instance declaration of `Arbitrary`. This allows QuickCheck to generate arbitrary Edges.

One of the properties of `removeHeavierDuplicates` is that it never returns a longer list than it was passed as a parameter. A property test was written to check this, and this failed. However, upon closer inspection, it immediately became apparent that this was because the `>=` operator had been used instead of `<=` in the test itself. This was amended, and the test rerun and passed.

Another of the properties of `removeHeavierDuplicates` is that no two Edges in the returned list should have the same start and end values.

---------

The next function to implement was `chooseRandomPath`, which should take a random number generator of type `StdGen` and a list of Edges, and should return a list of Edges containing a subset of the initial list. For generators with different seed values, different selections of edges should be generated. 

Writing tests for this function proved to be more complicated. One initial idea was to simply call the function twice with generators which have seeds which are guaranteed to be different, and test if the outputs differ. The problem with this is that the outputs may well be the same for different seeds, especially with shorter lists of Edges (and must be the same if the list is empty).  

A simpler property to test is that `chooseRandomPath` does not return a greater number of edges than it is given. A test was written to test this, and the function was made to pass this. As this requires a `StdGen` as a parameter, `StdGen` also needed an instance declaration of `Arbitrary`. This was done in the same way as it was for `Edge`. However, this test could be passed by just making the function return its input. 

One way to guarantee the outputs are different is to provide two `StdGen`s which are known to return different values when they are run. To do this, a new type `StdGenDiffPair`, isomorphic with (`StdGen`, `StdGen`), was declared; the `suchThat` predicate was used in the `Arbitrary` instance declaration of this new type to ensure that the first `Bool` values generated by each of the `StdGen`s are different. This was done by using the `next` function to look ahead. However, if the list is empty, the return values must still be equal, so a generator had to be defined to generate a list which is guaranteed not to be empty. As such, `EdgeListNonEmpty` was declared and set up in much the same way as `StdGenDiffPair`. These types could then be used by a new property test `prop_chooseRandomPathReturnsDifferentPathsForDifferentRngs`, which tests that so long as the `StdGen`s return different values, and the list of edges is not empty, the `chooseRandomPaths` function returns different paths. This new property test failed on running, so the function was modified so that this would pass.

As the returned list of edges represents a path, a type synonym `Path = [Edge]` was added at this point, and used in place of `[Edge]` as the return value of `chooseRandomPath`. After this change, the tests were all re-run.


--------

In order to create a list of candidate paths, a function had to be created to return a list of random paths, given a `StdGen`, a list of edges, and an `Int` representing the number of paths to be created. The returned list must have a length the same as the number of paths to be created, so this made a logical first property test. In the case that the number of paths to be created is zero or less, an empty list should be returned. This test was created, failed, and the function was implemented to pass this test by returning a list of paths of the correct length, but simply using the full list of edges as each path, instead of a random subset of these. This test initially used guards to check if `num < 0`, and to return `True` if this is the case. The problem with this is that the test itself became too large, so this was replaced with another `newtype` and `instance` declaration, this time for `IntAtLeastOne`, which allows for the generation of ints which are guaranteed to be at least one.

The sets of paths should differ for generators which are guaranteed to give different values, so a test `prop_chooseRandomPathsDiffersWithG` was created to test this. The previously created `StdGenDiffPair` was used again here, as was `EdgeListNonEmpty`. Test failed, code changed to use `chooseRandomPath` function, 

The paths within the set should not all be identical, so another test was written to check that at least one of the paths is different from the first in the list. This failed, and the function was modified so that the paths differ. A problem encountered, however, was that the arbitrary `StdGen`s used in by the tests may happen to return the same value for the first two random numbers. If this happens, and the number of paths to generate is only two, then the two paths will be the same if the number of edges is only one. The reason for this is that there is only one edge, and this either is or is not in a path, and if the first two values returned by the generator are the same then whether this is present will be the same in the first two paths. In addition, if only one path is generated, there cannot be variation between paths. To resolve this, the test was improved by adding one to the `IntAtLeastOne`, therefore making it at least two, and another `newtype` & `instance` were added to create a new generator which creates `StdGen`s which are guaranteed to return different boolean values the first two times they are used.   

The test generators at this point had become to take up quite a lot of the tests file, so at this point they were refactored out to a separate file.


--------


The next step was to create a function to return the best paths from a set. This should take a list of paths and the number to return. The length of the returned list should be the lesser of either the length of the original list or the number to return, so a test was written to test this.

The next property to test was whether the paths returned are the highest scorers. In order to write this test and implement the function itself, a scoring function needed to be implemented.

The `scorePath` function returns an `Int` representing the score of the path. The scoring is to be done as follows:


--------

At this point I defined a `runAllTests` function to run the tests all at once, and modified the `Main.hs` file to run this function, as running tests through the REPL had become tedious.



---------




# Libraries Used


 Test.QuickCheck
 Test.HUnit
 System.Random
 Data.Sort

