% Advanced Software Engineering Functional Test-driven Development Report
% Daniel Holland N0697611

\pagebreak

# Test Driven Development

## Explanation of what TDD is

Test Driven Development is an approach to software development in which automated Unit Tests are written before code is, and then code is written to pass the new Unit Tests (Beck, K., 2003). Once this has been done, the code is refactored to remove duplication, and all tests are re-run to check that no regressions have occurred (Beck, K., 2003).

Test Driven Development thus gives programming the following structure (Beck, K., 2003):

1. Write a small test that does not pass
2. Make the test pass
3. Refactor the code, eliminating any duplication in the process


## Critical Evaluation of TDD


My own impression of Test Driven Development is that it is likely to be more useful the larger the program, and particularly when the program is maintained by many different developers (or even organisations). One issue from my own experience in industry however, is the if not appropriately named, structured, and commented, Unit Tests may be removed by future developers if they fail.  They are particularly likely to do this if they are not able to quickly discern the purpose of the test, and if they see no obvious symptoms. This defeats the objective of the original test writing. As such this is a process which requires not just discipline, but that it becomes a habit. The usage of this method in an organisation therefore requires that it becomes thoroughly inculcated in the organisation and its culture.

Another issue with Unit Tests I encountered in industry was that for a code base which contains many impure elements, a large amount of time is spent mocking the behaviour of impure elements, such as Data Access Objects, so that test data can be generated for the pure functions to be tested. With certain types of application, such as a CRUD Web Service, this is going to be a larger issue than with others, such as implementations of sorting and searching algorithms.


Maximilien, E.M. and Williams, L. (2003) details how IBM reduced their defect rate by 50% by using Test Driven Development as opposed to an ad-hos unit testing approach. However, whilst George, B. and Williams, L. (2004) also found TDD produced code that was of a higher quality (it passed 18% more functional black-box test cases), it is admitted that the code also took 16% longer to write. George, B. and Williams, L. (2004) also suggests that "waterfall-like approaches do not encourage adequate testing", testing not being core to the process, but rather being an afterthought. From this George, B. and Williams, L. (2004) suggests that increased usage of Test Driven Development would increase usage of Unit Testing generally. 


\pagebreak
# Using TDD

To try out Test Driven Development, I partially developmed a program intended to find the shortest path between two nodes in a network. The network was to be generated at pseudo-random.

The network must consist of Nodes, which must haven directional weighted Edges to other Nodes. 
To find the shortest path, a Genetic Algorithm was to be used.

This has the following process:

1. Generate pseudo-random Paths, made of selections of Edges from the Network 
2. Score the paths, for:
  1. Whether Start at the first Node
  2. Whether they End at the second
  3. Their total Weight
3. If not at the final generation, generate new Paths as follows, then return to step 2:
  1. Take the top ranking Paths, and to fill the whole of a new set with duplicates of these
  2. Add mutations to these by randomly adding and removing edges
  3. Mate these by taking pairs of Paths, slicing the Paths at random positions and fusing the paths back together 
4. Return the best scoring path


Before this could be started, however, first a random network generator had to be created.

This 

Random networks generated should have nodes. The number of nodes should pseudo-random between  specified min and max values. Each Node should have a number of Edges, which should be pseudo-random between one and a specified max value, each of which has a weight and a reference to another Node.

A test was written to check that buildRandomNetwork returns a result which has a length of at least the minimum value given to it. The function was then implemented to return 

#

 
This should have the following parameters: A `StdGen` random number generator, the minimum and maximum numbers of Nodes, and the maximum number of Edges per Node.



 represent a network

A network exists, with a number of nodes, and a number of edges. Edges are directional from one node to another.

Edges have a start node, an end node, and a weight. Edges are uni-directional.




For all edges, a pseudo-random subset (of a pseudo-random size between zero and the number of edges) of these should be chosen.
- The size of the subset must not exceed the total number of edges.
- The subset must 



nodesConnected function

If nodes are connected directly, nodesConnected should return True. A unit test `directlyConnectedNodesAreConnected` was created to test this on two example nodes. The function was made to return True.

Then, another test,`notConnectedNodesAreNotConnected`, was written to check that the function does not return True when the node order is reversed, as they are not connected in reverse. 
This still returned true, so the function was changed to fix this. 

If the nodes are indirectly connected, indirectlyConnectedNodes

But if the 


# Reflection on using Test-Driven Development, Functional Programming, and testing tools

## What went well

### reasons

## What could have gone better

### Reasons

## What should be done in the future

In the future

\pagebreak

# References

Beck, K., 2003. Test-driven development: by example. Addison-Wesley Professional.

George, B. and Williams, L., 2004. A structured experiment of test-driven development. Information and software Technology, 46(5), pp.337-342.

Maximilien, E.M. and Williams, L., 2003, May. Assessing test-driven development at IBM. In 25th International Conference on Software Engineering, 2003. Proceedings. (pp. 564-569). IEEE.

