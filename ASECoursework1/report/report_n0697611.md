% Advanced Software Engineering Software Development Investigation Report
% Daniel Holland N0697611
 
\pagebreak

## Task 1
### Task 1b
##### Constructor - Always O(1)
```c++
Dictionary();
```
Constant, as an empty dictionary is created, and nothing happens to it except that the pointer to the first node is set to null, which is a constant time operation.

##### Copy Constructor - Always O(n)
```c++
Dictionary(const Dictionary &);
```
As it depends on the size of the dictionary. Each node must be copied, copying a single node is constant time, and this happens for each node, so O(n) overall.


##### Move Constructor - Always O(1)
```c++
Dictionary(Dictionary&&) noexcept;
```
A new empty dictionary is created, the first node pointer of which is pointed to the same node as the first node pointer of the other dictionary, and the first node pointer of the other dictionary is then made null. These operations are constant time, therefore O(1) overall.

##### Destructor - Always O(n)
```c++      
~Dictionary();
```
Each node must be deleted individually, which is affected by the number of nodes and therefore O(n).


##### Insert - Best case O(1), Worst case O(n), Average case O(n)
```c++  
bool insert(Key, Item);
```
Best case is that the key to insert matches the first key, so the item replaces its item, which is O(1). Worst case is key is not in dictionary, so every key checked (which is O(n)) before inserting a new item. Average case will be between inserting at node's average position (half way through, complexity of order O(n)) and key absent (also O(n)), therefore average case O(n).

##### Lookup - Best case O(1), Worst case O(n), Average case O(n)

```c++
Item *lookup(Key);
```
Best case is that the item sought is the first checked, which is O(1). Worst case is key is not or is last in the dictionary, so every key checked (which is O(n)). Average case will be between case for node's average position (half way through, complexity of order O(n)) and item absent/last (also O(n)), therefore average case O(n).

##### Remove - Best case O(1), Worst case O(n), Average case O(n).
```c++  
bool remove(Key);
```

Best case is that the node to remove is the first checked, which is O(1). Worst case is the key is not or is last in the dictionary, so every key checked (which is O(n)). Average case will be between case for node's average position (half way through, complexity of order O(n)) and key absent/last (also O(n)), therefore average case O(n).

##### Remove If - Always O(n)
```c++
int removeIf(Predicate);
```
Every node is always checked, which is O(n). Worst case would be every node is removed aswell, but still O(n) overall as both operations are O(n).


##### Copy Assignment Operator - Always O(n)
```c++
Dictionary & operator=(const Dictionary &);
```
It depends on the size of the dictionaries. Nodes on the copied to dictionary must first all be removed, which is O(n), and then the nodes from the copied from dictionary must be copied over, which is also O(n). Both operations O(n) therefore O(n) overall.
 
 
##### Move Assignment Operator - Always O(1)
```c++
Dictionary & operator=(Dictionary&& other) noexcept;
```
The pointer to the first node of the target must be pointed to the other dictionary's first node, then the other dictionary's first node pointer is made null. Both operations O(1), therefore O(1) overall.

\pagebreak

## Task 2
### Task 2a
#### List
```c++
std::list
```
A doubly-linked list is used to implement `std::list` (Cplusplus.com, 2019). A doubly-linked list consists of nodes, each of which contains a pointer to its successor and predecessor. Pointers to the first and last nodes in the list are stored, and by following the successor and predecessor pointers from these, it is possible to navigate to any node in the list. When a new node is added to the doubly-linked list, the pointers of the nodes immediately before and after the position of this new node are re-pointed to this new node, and this new node's pointers are pointed too its neighbours. If inserting at the start or end of the list, only the first or last node must have its pointers adjusted.

##### Insertion
List has three insertion functions, all of time complexity O(1): `std::list::insert`, `std::list::push_front`, and `std::list::push_back`. However, `insert` requires an iterator, and moving this iterator to a position in the list from the front or back is a O(n) time complexity operation. `push_front` and `push_back` (which are just insertions at the front/back) are both always O(1) because the doubly-linked list always stores the first and last position, so these positions can be accessed in constant time.

###### How a doubly-linked list enables insertion into to a list to be guaranteed to O(1) at front and back

##### Search
`std::find` â†’ O(n)

###### Why searching a doubly linked list is O(n)

##### 

\pagebreak
#### Map
```c++
std::map
```
A self-balancing binary search tree is typically used to implement `std::map` (Cplusplus.com, 2019). A binary search tree, like a doubly linked list, consists of nodes, each with two pointers. However, it differs from a doubly-linked list in the structure created using these nodes. The binary search tree's nodes have a left and right pointer, which is either a `nullptr`, representing a leaf of the tree, or a pointer to another node. The left child's key is always smaller, and the right child's key is always larger, when compared to the key of the node. 

##### Insertion
Map has two equivalent insertion functions, `std::map::insert` and `std::map::operator[]`. Both have time complexity O(log n) (Riesbeck, C. n.d.). 
 
##### Search
If a key is known to be present in a map, `std::map::operator[]` can be used to return a reference to it (this will otherwise create a new element with the key). If it is unknown whether the key exists, `std::map::find` may be used to search for it. Both are of time complexity O(log n).

##### How a Binary Search Tree enables insertion and searching of map to be guaranteed to be O(log n)

#### Unordered Map
```c++
std::unordered_map
```
A hash-table is typically used to implement an unordered map (GeeksforGeeks, 2017). 

##### Insertion
Like map, unordered map has two equivalent insertion functions, `std::map::insert` and `std::map::operator[]`. However, for unordered map, these functions have an average time complexity of O(1), and a worst case time complexity of O(n).

##### Search


##### How a Hash-Table implementation gives the unordered map these performance characteristics

### Task 2b
Two data structures are necessary: the first is one well suited to searching for records, the second is one well suited to the insertion of records at the front and back.

#### Combination 1 - `map` for the first data structure, `list` for the second. 

##### Time Complexity + Explanation
`map` has a time complexity of O(log n) for both inserts and searches. The items must be inserted into and then searched for in the first data structure. The second data structure only requires that items are inserted at the front and back, before the whole sequence is iterated through once at the end to output the final order. `list` has a time complexity of O(1) to insert at the front and back, making it well suited to this task. 

##### Space usage + Explanation
The list structure itself will take up more space than storing the data in one contiguous block 

#### Combination 2 - `unordered_map` for the first data structure, `list` for the second.

##### Time Complexity + Explanation

##### Space usage + Explanation


#### Combination 3 - `unordered_map` for both the first and second data structures.

##### Time Complexity + Explanation

##### Space usage + Explanation


#### Choice

##### Justification

\pagebreak
## Task 3

### Task 3b

\pagebreak
## Task 4

### Task 4a

### Task 4c


\pagebreak
## References

Cplusplus.com. (2019). Reference - C++ Reference. [online] Available at: [http://www.cplusplus.com/reference/](http://www.cplusplus.com/reference/).

John Ahlgren: STL Container Performance (2013). [online] John Ahlgren. Available at: [http://john-ahlgren.blogspot.com/2013/10/stl-container-performance.html](http://john-ahlgren.blogspot.com/2013/10/stl-container-performance.html).

GeeksforGeeks. (2017). map vs unordered_map in C++. [online] Available at: [https://www.geeksforgeeks.org/map-vs-unordered_map-c/](https://www.geeksforgeeks.org/map-vs-unordered_map-c/) [Accessed 20 Feb. 2020].


\pagebreak
## Bibliography

Riesbeck, C. (n.d.) EECS 311: STL Containers. [online] users.cs.northwestern.edu. Available at: [https://users.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html](https://users.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html) [Accessed 20 Feb. 2020].

