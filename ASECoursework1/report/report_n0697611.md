###### ASE Report
## Daniel Holland 
\pagebreak

## Task 1
### Task 1b
##### Constructor
```c++
Dictionary();
```
Time complexity always O(1). Constant, as an empty dictionary is created, and nothing happens to it except that the pointer to the first node is set to null, which is a constant time operation.

##### Copy Constructor
```c++
Dictionary(const Dictionary &);
```
Time complexity always O(n), as it depends on the size of the dictionary. Each node must be copied, copying a single node is constant time, and this happens for each node, so O(n) overall.


##### Move Constructor
```c++
Dictionary(Dictionary&&) noexcept;
```
Time complexity always O(1). A new empty dictionary is created, the first node pointer of which is pointed to the same node as the first node pointer of the other dictionary, and the first node pointer of the other dictionary is then made null. These operations are constant time, therefore O(1) overall.

##### Destructor
```c++      
~Dictionary();
```
Time complexity always O(n). Each node must be deleted individually, which is affected by the number of nodes and therefore O(n).


##### Insert
```c++  
bool insert(Key, Item);
```
Time complexity best case O(1), worst case O(n), typical case O(n). Best case is that the key to insert matches the first key, so the item replaces its item, which is O(1). Worst case is key is not in dictionary, so every key checked (which is O(n)) before inserting a new item. Typical case will be between inserting at node's average position (half way through, complexity of order O(n)) and key absent (also O(n)), therefore typical case O(n).

##### Lookup
```c++
Item *lookup(Key);
```
Time complexity best case O(1), worst case O(n), typical case O(n). Best case is that the item sought is the first checked, which is O(1). Worst case is key is not or is last in the dictionary, so every key checked (which is O(n)). Typical case will be between case for node's average position (half way through, complexity of order O(n)) and item absent/last (also O(n)), therefore typical case O(n).

\pagebreak
##### Remove
```c++  
bool remove(Key);
```
Time complexity best case O(1), worst case O(n), typical case O(n). Best case is that the node to remove is the first checked, which is O(1). Worst case is the key is not or is last in the dictionary, so every key checked (which is O(n)). Typical case will be between case for node's average position (half way through, complexity of order O(n)) and key absent/last (also O(n)), therefore typical case O(n).

##### Remove If
```c++
int removeIf(Predicate);
```
Time complexity always O(n), as every node is always checked, which is O(n). Worst case would be every node is removed aswell, but still O(n) overall as both operations are O(n).


##### Copy Assignment Operator
```c++
Dictionary & operator=(const Dictionary &);
```
Time complexity always O(n), as it depends on the size of the dictionaries. Nodes on the copied to dictionary must first all be removed, which is O(n), and then the nodes from the copied from dictionary must be copied over, which is also O(n). Both operations O(n) therefore O(n) overall.
 
 
##### Move Assignment Operator
```c++
Dictionary & operator=(Dictionary&& other) noexcept;
```
Time complexity always O(1), as the pointer to the first node of the target must be pointed to the other dictionary's first node, then the other dictionary's first node pointer is made null. Both operations O(1), therfore O(1) overall.

\pagebreak

## Task 2
### Task 2a
```c++
  std::list
```

```c++
  std::map
```

```c++
  std::unordered_map
```

### Task 2b

\pagebreak
## Task 3
### Task 3a
### Task 3b

\pagebreak
## Task 4
### Task 4a
### Task 4c
